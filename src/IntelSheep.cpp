#include "IntelSheep.h"
#include <algorithm>

IntelSheep::IntelSheep(const SpatialVector& pos, const SpatialVector& vel) : Thing(pos, vel) {
//~ IntelSheep::IntelSheep(const SpatialVector& pos, const SpatialVector& vel, World* world) : Thing(pos, vel, world) {
	
	m_speed					= 1.0;
	m_friction				= 0.0;
	m_mass					= 100.0;
	m_eatingRange			= 10.0;
	m_perceptionRange		= 50.0;
	m_healthConsumption		= 0.1;
	m_health				= 100.0;
	m_healthOld				= 100.0;
	
	m_classID				= 5;
	
	m_log.open("log.txt");
}

IntelSheep::~IntelSheep(){
	m_log.close();
}

void IntelSheep::perceive(World* world) {
	//~ std::list<ThingPtr> m_thingsInSight
	m_thingsInSight = world->getThings(m_position, m_perceptionRange, m_velocity, M_PI_4);
	
	// NOTE: maybe put filtering for closest object into getThings, add argument unsigned int numClosestObjects, 0 means all
	
	
	// NOTE: For now, the intelSheep is confused by more than 10 objects
	const unsigned int maxNumObjects = 10;
	if (m_thingsInSight.size() > maxNumObjects){
		// Sort all percieved things according to their distance
		std::vector<double> distances(maxNumObjects, 0.0);
		for(std::list<ThingPtr>::const_iterator it = m_thingsInSight.begin(); it != m_thingsInSight.end(); ++it) {
			distances.push_back(((*it)->getPosition() - m_position).length());
		}
		std::sort(distances.begin(), distances.end());
		// Remember the distance of the farest object we can handle
		double threshold = distances[maxNumObjects];
		
		// Remove all perceived objects that are further away
		for(std::list<ThingPtr>::iterator it = m_thingsInSight.begin(); it != m_thingsInSight.end(); ) {
			double distance = ((*it)->getPosition() - m_position).length();
			if (distance > threshold) {
				m_thingsInSight.erase(it);
			} else {
				++it;
			}
		}
	}
	
}



// Always write the maximal number of percieved objects
void IntelSheep::logPerception(){
	const unsigned int minNumberObjects = 10;
	for(std::list<ThingPtr>::iterator it = m_thingsInSight.begin(); it != m_thingsInSight.end(); ++it) {
		m_log << (*it)->getClassID() << " " << (*it)->getPosition() << " ";
	}
	for(unsigned int i = 0; i < (minNumberObjects-m_thingsInSight.size()); ++i ) {
		m_log << 0 << " " << 0.0 << " " << 0.0 << " " << 0.0 << " ";
	}
}

void IntelSheep::progress(double dt, World* world) {
	
	// log the status
	m_log << m_health << " " << m_position;
	//velocity[0] << " " << velocity[1] << " " << velocity[2] << " ";
	
	perceive(world);
	// log the percieved objects
	logPerception();
	
	// ANA: AI processing here!
	
	// SG: the most intelligent movement ever:
	// m_velocity.randomize();
	
	move(dt, world);
	
	// TODO: change this:
	// current: percieved again to eat
	// target: only check already percieved objects for deliciousness
	std::list<ThingPtr> thingsInFront = world->getThings(m_position, m_eatingRange, m_velocity, M_PI_4);
	for(std::list<ThingPtr>::iterator it = thingsInFront.begin(); it != thingsInFront.end(); ++it) {
		// eat the berries (berry class ID = 1)!
		if ((*it)->getClassID() == 1) {
			m_health += (*it)->transferHealth(this);
		}
	}
	// TODO: log all actions
	
	
	
	// TODO: log outcome
	
	m_healthOld = m_health;
	
}

void IntelSheep::move(double dt, World* world) {
	
	m_velocity.normalize(m_speed);	// ANA: intelsheep has a constant speed
									// ANA: velocity direction shall be generated by NN
									
	Thing::move(dt, world);

	m_health -= m_healthConsumption * dt;
	
}



